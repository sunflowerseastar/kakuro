* kakuro

|      | :d 4 | :d 6 |
| :r 3 |      |      |
| :r 7 |      |      |

Overall board data structure is a nested arrayâ€”rows of squares, each of which is type ~:black~, ~:entry~, or ~:flag~:

#+begin_src clojure
[[{:type :black :x 0 :y 0}
    {:type :flag :x 1 :y 0 :flags #{{:direction :down :sum 4 :distance 2}}}
    {:type :flag :x 2 :y 0 :flags #{{:direction :down :sum 6 :distance 2}}}]
   [{:type :flag :x 0 :y 1 :flags #{{:direction :right :sum 3 :distance 2}}}
    {:type :entry :x 1 :y 1}
    {:type :entry :x 2 :y 1}]
   [{:type :flag :x 0 :y 2 :flags #{{:direction :right :sum 7 :distance 2}}}
    {:type :entry :x 1 :y 2}
    {:type :entry :x 2 :y 2}]]
#+end_src

Aside: the x/y's are redundant, in the sense that they could be calculated as their respective matrix positions. It is maintained because it's useful when elements need to know their x/y values late in a composition chain, and it would require extra effort to either thread the x/y's along with all the functions or manage a lifted state.

The solver only needs to know the flags. Note that one square can have two flags, so the number of flag squares and flags is different in some scenarios.

There is a compact notation for the solver, ~flags-to-be-solved~:

#+begin_src clojure
;; [:direction x y sum distance]

(def flags-to-be-solved
  [[:d 1 0 4 2]
   [:d 2 0 6 2]
   [:r 0 1 3 2]
   [:r 0 2 7 2]])
#+end_src

These are passed to the ~solve/~ API call:

#+begin_src clojure
(POST "http://localhost:3001/solve"
      {:headers {"content-type" "application/edn"}
       :body "{:flags-to-be-solved flags-to-be-solved}"
       :handler #(.log js/console (str "response: " %))
       :error-handler #(.error js/console (str "error: " %))})
#+end_src

...which returns a solution:

#+begin_src clojure
[1 2 3 4]
#+end_src

The numbers in the solution correspond to the entry values:

#+begin_src
[[1 2]
 [3 4]]
#+end_src

Final result:

|      | :d 4 | :d 6 |
| :r 3 |    1 |    2 |
| :r 7 |    3 |    4 |
